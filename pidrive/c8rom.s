;****************************************
;*
;*      OPTION ROM SPACE @ $C800
;*
;****************************************
;*
;* RETURN SLOT*16 IN X REG, SLOT IN Y REG
;*
GETSLOT:
	TSX
	LDA	$102,X		; GET MSB OF RETURN ADDRESS
	STA	IOSLOT
	AND	#$0F
	TAY
	LDA	SLOT16
	STA	SAVE16,Y	; SAVE SLOT16 LOCATION
	TYA
	ASL
	ASL
	ASL
	ASL
	STA	SLOT16
	TAX
	RTS
;*
;* OUTPUT BYTE TO ACIA
;*
SENDACC:
	PHA
	LDA	SLOT16
	ORA	#$89+1		; ACIASR
	TAX
SENDWT:	LDA	$C000-1,X
	AND    	#$10
	BEQ	SENDWT
	DEX			; ACIADR
	PLA
	STA	$C000-1,X	; AVOID PHANTOM READ OF DATA REG
	RTS
;*
;* INPUT BYTE FROM ACIA
;*
RECVACC:
	LDX	SLOT16
RECVWT:	LDA	ACIASR,X
	AND	#$08
	BEQ	RECVWT
	LDA	ACIADR,X
	RTS
;*
;* WAIT FOR DELAY
;*
WAIT:	SEC
WAIT2:	PHA
WAIT3:	SBC	#$01
	BNE	WAIT3
	PLA
	SBC	#$01
	BNE	WAIT2
	RTS
;*
;* SYNC WITH HOST
;*
SYNC:	LDA	INDCTR
	PHA
	LDA	#$0B
	STA	ACIASR,X       	; RESET STATUS REGISTER
	STA	ACIACR,X       	; SET CONTROL REGISTER
	LDA	#$10
	STA	ACIAMR,X	; SET COMMAND REGISTER (115K BAUD)
	LDA	#$80
	JSR	WAIT
	STA	STROBE		; CLEAR KEYBOARD STROBE
SYNCLP:	LDA	#SYNC_REQ
	JSR	SENDACC
	INY
	TYA
	AND	#$07
	TAY
	LDA	SPIN,Y
	STA	INDCTR
	LDA	#$FF
	JSR	WAIT
	LDA	KEYBD
	BPL	CHKRSP
	STA	STROBE
	PLA
.IFNDEF	DEBUG
	STA	INDCTR
.ENDIF
NODEV:	LDA	#PDNODEV
	RTS
SPIN:	DB	$A1, $AF, $AD, $DC, $A1, $AF, $AD, $DC
CHKRSP: LDX	SLOT16
	LDA	ACIASR,X
	AND	#$08
	BEQ	SYNCLP
	LDA	ACIADR,X
	CMP	#SYNC_ACK
	BNE	SYNCLP
	LDA	IOSLOT
	AND	#$0F
	TAY
	LDA	#SYNC_ACK
	STA	SYNCED,Y
	PLA
.IFNDEF	DEBUG
	STA	INDCTR
.ENDIF
	LDA	#$00
	RTS
RESYNC:	JSR	SYNC
	BEQ	DOCMD
	RTS
;*
;* DO STATUS, READ, WRITE COMMAND
;*
DOCMD:	LDA	ACIACR,X	; CHECK FOR ANY REASON TO RESYNC
	CMP	#$0B
	BNE	RESYNC
	LDA	ACIAMR,X
	CMP	#$10
	BNE	RESYNC
	LDA	SYNCED,Y
	CMP	#SYNC_ACK
	BNE	RESYNC
	LDA	PDUNIT		; FORMAT COMMAND FOR SIDRIVE AND SEND IT
	ASL
	LDA	PDCMD
	ROL
	ASL
	ORA	#$A0
	JSR	SENDACC
	CLC
	ADC	#$01
	STA	CMDACK,Y
	LDA	PDBLKL
	JSR	SENDACC
	LDA	PDBLKH
	JSR	SENDACC
CHKACK: JSR	RECVACC		; WAIT FOR CORRECT ACK (MAY BE OUTSTANDING A2PI REQUESTS)
	CMP	CMDACK,Y
	BNE	CHKACK
;*
;* BRANCH TO COMMAND HANDLER
;*
 	LDA	PDCMD
	AND	#$03
	TAY			; CPY #PDSTATUS
	BEQ	STATUS
	DEY			; CPY #PDREAD
	BEQ	RDBLK
	DEY			; CPY #PDWRITE
	BEQ	WRBLK
.IFDEF	DEBUG
	LDA	#'?'
	STA	INDCTR+6
.ENDIF
IOERR:	LDA	#PDIOERR
	RTS
;*
;* SIDRIVE STATUS - RETURN NUMBER OF BLOCKS OR NODEV
;*
STATUS:
.IFDEF	DEBUG
	LDA	#'S'-$40
	STA	INDCTR+3
.ENDIF
	LDA	IOSLOT
	AND	#$0F
	TAY
	JSR	RECVACC
	STA	SCRTCH6,Y
	JSR	RECVACC
	STA	SCRTCH7,Y
	JSR	RECVACC
	PHA
	LDX	SCRTCH6,Y
	LDA	SCRTCH7,Y
	TAY
	PLA
	RTS
;*
;* READ A BLOCK (512 BYTES) FROM SIDRIVE
;*
RDBLK:
.IFDEF	DEBUG
	LDA	#'R'-$40    	; LDY #$00
	STA	INDCTR+4
.ENDIF
RDBLKL:	JSR	RECVACC
	STA	(PDBUFF),Y
	INY
	BNE	RDBLKL
	INC	PDBUFH
RDBLKH:	JSR	RECVACC
	STA	(PDBUFF),Y
	INY
	BNE	RDBLKH
	JMP	RECVACC
;*
;* WRITE A BLOCK (512 BYTES) TO SIDRIVE
;*
WRBLK:
.IFDEF	DEBUG
	LDA	#'W'-$40    	; LDY #$00
	STA	INDCTR+5
.ENDIF
WRBLKL:	LDA	(PDBUFF),Y
	JSR	SENDACC
	INY
	BNE	WRBLKL
	INC	PDBUFH
WRBLKH:	LDA	(PDBUFF),Y
	JSR	SENDACC
	INY
	BNE	WRBLKH
	JMP	RECVACC
.IFDEF	ALTBOOT
;*
;* PRINT THE BOOT MESSAGE AT THE TOP OF THE SCREEN
;*
PUTMSG:	LDY	#$00
PUTC:	LDA	MSG,Y
	BMI	FILLEOL
	ORA	#$80
	STA	MSGLN,Y
	INY
	BNE	PUTC
MSG:	DB	"PRESS 'M' FOR BOOT MENU", $A0
;*
;* CLEAR THE MESSAGE AT THE TOP OF THE SCREEN
;*
CLRMSG:	LDY	#$00
	LDA	#$A0
FILLEOL:
	STA	MSGLN,Y
	INY
	CPY	#40
	BNE	FILLEOL
	RTS
.ENDIF
